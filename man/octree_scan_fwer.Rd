% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/octree_scan.R
\name{octree_scan_fwer}
\alias{octree_scan_fwer}
\title{Octree Max-Scan with permutation FWER (U0-only)}
\usage{
octree_scan_fwer(
  z_vol,
  prior_vol = NULL,
  mask = NULL,
  alpha = 0.05,
  n_perm = 1000,
  null = c("signflip_voxel", "mc_fwhm", "mc_acf"),
  null_fun = NULL,
  fwhm_vox = NULL,
  fwhm_mm = NULL,
  acf_params = NULL,
  seed = NULL,
  two_sided = FALSE,
  prior_eta = 0.9
)
}
\arguments{
\item{z_vol}{A 3D volume-like object with finite values in-brain.}

\item{prior_vol}{Optional prior weight volume aligned to \code{z_vol}.
If NULL, uniform weights are used.}

\item{mask}{Optional logical mask (same shape as \code{z_vol}). If NULL,
uses all finite voxels in \code{z_vol}.}

\item{alpha}{Significance level for strong FWER control (default 0.05).}

\item{n_perm}{Number of permutations/sign-flips (default 1000).}

\item{null}{Null calibration method.
\describe{
\item{\code{"mc_fwhm"}}{Correlated Monte Carlo null via Gaussian smoothing
of white noise with smoothness set by \code{fwhm_vox} (or \code{fwhm_mm}
for \code{NeuroVol}s). If both are NULL, an effective \code{fwhm_vox} is
estimated from the statistic map using \code{\link{estimate_fwhm_vox}}.}
\item{\code{"mc_acf"}}{Correlated Monte Carlo null using a simple mixed-ACF
model (Gaussian + long-tailed exponential) with user-supplied parameters
\code{acf_params}.}
\item{\code{"signflip_voxel"}}{Independent voxelwise sign-flips of the
group map (fast but generally invalid for regional/multiscale statistics;
mainly useful for debugging).}
}}

\item{null_fun}{Optional function \code{function(b)} returning a length
\code{n_mask} Z-vector for permutation \code{b}. Use this to supply
subject-level randomization that preserves spatial covariance.}

\item{fwhm_vox}{For \code{null="mc_fwhm"}, Gaussian FWHM in voxel units
(length 1 or 3).}

\item{fwhm_mm}{For \code{null="mc_fwhm"}, Gaussian FWHM in mm (length 1 or 3).
Requires \code{z_vol} to be a \code{neuroim2::NeuroVol} so voxel spacing is
available.}

\item{acf_params}{For \code{null="mc_acf"}, a list with components:
\describe{
\item{a}{Mixing weight in (0, 1) for the Gaussian component.}
\item{fwhm_vox}{Gaussian ACF FWHM in voxel units (length 1 or 3).}
\item{lambda_vox}{Exponential kernel scale in voxel units (length 1 or 3).}
}}

\item{seed}{Optional RNG seed for reproducibility.}

\item{two_sided}{Logical; if TRUE, uses \code{abs(z_vol)} prior to sign-flips.}

\item{prior_eta}{Mixing weight in [0, 1] to shrink the prior toward uniform
mass (default 0.9).}
}
\value{
A list with components:
\describe{
\item{u}{Global maxT threshold at level \code{alpha}.}
\item{M_obs}{Observed max scan statistic.}
\item{M_null}{Numeric vector of permutation maxima.}
\item{nodes}{Data frame of all non-empty dyadic nodes with columns
\code{level,i,j,k,score,scale,x0,x1,y0,y1,z0,z1}.}
\item{sig_nodes}{Subset of \code{nodes} with \code{score > u}.}
\item{params}{List of run parameters.}
}
}
\description{
Computes a multiscale dyadic-cube scan statistic using the variance-stabilized
prior-weighted mean
\deqn{U_0(R) = \sum_{v \in R}\pi(v)Z(v)/\sqrt{\sum_{v \in R}\pi(v)^2}}
over all dyadic cubes in an implicit octree, and calibrates a global
threshold by a maxT permutation (sign-flip) procedure.
}
\details{
This implements the simplest global calibration: a single-step maxT
permutation threshold over the full dyadic-cube family.

If only a single group-level map is available, \code{null="mc_fwhm"} is a
safer default than voxelwise sign-flips because it preserves an assumed
spatial autocorrelation model. Exact resampling-based inference typically
requires subject-level or residual maps; supply \code{null_fun} to use such
randomizations.

For hierarchical step-down over sibling families during descent, see
\code{\link{octree_scan_stepdown}}.
}
\examples{
# Map-only (model-based) calibration using a Gaussian ACF null:
z <- array(rnorm(16 * 16 * 16), dim = c(16, 16, 16))
res <- octree_scan_fwer(z, n_perm = 50, null = "mc_fwhm", fwhm_vox = c(2, 2, 2))

# User-supplied mixed ACF parameters (Gaussian + long tail):
acf <- list(a = 0.7, fwhm_vox = c(4, 4, 4), lambda_vox = c(2, 2, 2))
res2 <- octree_scan_fwer(z, n_perm = 50, null = "mc_acf", acf_params = acf)

# Subject-level sign-flips (recommended when subject maps are available):
subj <- replicate(8, array(rnorm(16 * 16 * 16), dim = c(16, 16, 16)), simplify = FALSE)
sf <- make_null_fun_subject_signflip(subj)
res3 <- octree_scan_fwer(sf$z_vol, mask = sf$mask, n_perm = 50, null_fun = sf$null_fun)

}
